<html>
  <head>
    <title>node_editor</title>
    <meta charset="UTF-8" />
  </head>
  <body>
    <div>
      <canvas
        id="canvas1"
        style="border: 1px solid black;"
        width="800"
        height="600"
      ></canvas>
    </div>
    <div>
      <label for="cb_drawBackground">
        <input id="cb_drawBackground" type="checkbox" checked />Draw background
      </label>
      <label for="cb_drawVertices">
        <input id="cb_drawVertices" type="checkbox" checked />Draw vertices
      </label>
      <label for="cb_drawEdges">
        <input id="cb_drawEdges" type="checkbox" checked />Draw edges
      </label>
      <label for="cb_drawVerticeLabels">
        <input id="cb_drawVerticeLabels" type="checkbox" checked />Draw vertice
        labels
      </label>
      <label for="cb_drawEdgeLabels">
        <input id="cb_drawEdgeLabels" type="checkbox" checked />Draw edge labels
      </label>
    </div>
    <div>
      <input
        type="button"
        id="btn_updateOutput"
        value="Update"
        onclick="updateOutput();"
      />
      <textarea id="txt_output1" rows="5" cols="80"></textarea>
    </div>
    <script>
      let app = (function() {
        const qsl = q => document.querySelector(q);
        let mouseDown = false;
        const derp = abc => abc * 10;
        var canvas;
        var ctx;
        var backgroundImage = new Image();

        const makeVertice = (x, y) => {
          return { x: x, y: y };
        };
        const makeEdge = (v1, v2) => {
          return { v1: v1, v2: v2 };
        };
        const makeDrawTask = (params, updateFunc, drawFunc) => {
          return { params: params, updateFunc: updateFunc, drawFunc: drawFunc };
        };

        var PIXELS_PER_SECOND = 50;
        var FPS = 60;

        function xxx(vs) {
          var edges = vs.reduce((acc, cur, idx, arr) => {
            return idx == 0
              ? []
              : [...acc, [vertices[arr[idx - 1]], vertices[arr[idx]]]];
          }, []);
          return edges;
        }

        function zzz(p1, p2) {
          return Math.sqrt(
            Math.pow(Math.abs(p1.x - p2.x), 2) +
              Math.pow(Math.abs(p1.y - p2.y), 2)
          );
        }

        function calcStep(edge) {
          var cp1 = mapVerticeToCanvas(edge[0], canvas);
          var cp2 = mapVerticeToCanvas(edge[1], canvas);
          var dist = zzz(cp1, cp2);
          var tt = dist / PIXELS_PER_SECOND;
          var step = 1.0 / tt / FPS;

          return step;
        }

        function yyy(vs) {
          var edges = xxx(vs);
          dt = makeDrawTask(
            {
              edges: edges,
              finished: false,
              step: calcStep(edges[0]),
              pct: 0.0
            },
            p => {
              return {
                edges: p.pct >= 1.0 ? p.edges.slice(1) : p.edges,
                finished: p.edges.length == 0,
                pct: p.pct < 1.0 ? p.pct + p.step : 0,
                // if pct is >= 1.0, we've moved on to the next edge
                // and should recalculate step for the NEXT edge, except
                // if we're already on the last edge, in which case we just
                // skip the calculation. with pct < 1.0 there is no
                // need to recalculate the step
                step:
                  p.pct >= 1.0
                    ? p.edges.length > 1
                      ? calcStep(p.edges[1])
                      : p.step
                    : p.step
              };
            },
            p => {
              ctx.lineWidth = 2;
              ctx.strokeStyle = "red";
              if (p.edges.length > 0) {
                ctx.beginPath();
                drawEdge(p.edges[0][0], p.edges[0][1], p.pct);
                ctx.stroke();
              }
            }
          );
          return dt;
        }
        var vertices = [];
        var edges = [];
        var drawTasks = [];
        var selectedVertices = [];
        var selectedEdges = [];

        canvas = qsl("#canvas1");
        ctx = canvas.getContext("2d");

        var options = {
          drawVertices: false,
          drawEdges: false,
          drawBackground: false,
          drawVerticeLabels: false,
          drawEdgeLabels: false,
          drawTasksEnabled: true
        };

        function processDrawTasks() {
          if (options.drawTasksEnabled == false) return;
          if (drawTasks.length != 0) {
            var i, j, m, n;
            var dt;
            var p, d;
            for (i = 0; i < drawTasks.length; i++) {
              dt = drawTasks[i];
              dt.params = dt.updateFunc(dt.params);
              dt.drawFunc(dt.params);
            }
            var dts = drawTasks.filter(e => {
              return e.params.finished == false;
            });
            drawTasks = dts;
          }
          window.requestAnimationFrame(processDrawTasks);
        }

        function updateOutput() {
          var o = {
            vertices: vertices,
            edges: edges
          };
          qsl("#txt_output1").innerText = JSON.stringify(o);
        }

        function update() {
          options.drawVertices = qsl("#cb_drawVertices").checked;
          options.drawBackground = qsl("#cb_drawBackground").checked;
          options.drawEdges = qsl("#cb_drawEdges").checked;
          options.drawVerticeLabels = qsl("#cb_drawVerticeLabels").checked;
          options.drawEdgeLabels = qsl("#cb_drawEdgeLabels").checked;
        }

        function init() {
          canvas.addEventListener("click", canvasEventHandler);
          document.addEventListener("keyup", canvasEventHandler, true);
          canvas.addEventListener("mousedown", e => {
            e.preventDefault();
            e.stopPropagation();
            if (e.buttons == 2) {
            } else if (e.buttons == 1) {
              mouseDown = true;
            }
          });
          canvas.addEventListener("blur", e => {
            mouseDown = false;
          });
          canvas.addEventListener("contextmenu", e => {
            e.preventDefault();
            e.stopPropagation();
            selectedVertices = [];
            selectedEdges = [];
            draw();

            mouseDown = false;
          });
          canvas.addEventListener("mouseup", e => {
            mouseDown = false;
          });
          canvas.addEventListener("mousemove", e => {
            if (mouseDown) {
              var v = vertices[selectedVertices[0]];
              if (v == null) {
                return;
              }
              var cv = mapVerticeToCanvas(v, canvas);
              var ce = mapInputEventToCanvas(e, canvas);
              var xd = Math.abs(cv.x - ce.x);
              var yd = Math.abs(cv.y - ce.y);
              var d = Math.sqrt(Math.pow(xd, 2) + Math.pow(yd, 2));
              if (d > 50) return;
              v.x = ce.x / canvas.width;
              v.y = ce.y / canvas.height;
              draw();
            }
          });
        }

        function mapVerticeToCanvas(v, c) {
          if (v == null) {
            console.log("how did we end up here");
          }
          return { x: v.x * c.width, y: v.y * c.height };
        }
        function mapInputEventToCanvas(event, canvas) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          return { x: x, y: y };
        }
        function drawVertices(vs) {
          for (var i = 0; i < vs.length; i++) {
            var v = vs[i];
            if (v == null) continue;
            drawVertice(v);
          }
          ctx.stroke();
        }

        function drawEdges(es, vs) {
          for (var i = 0; i < es.length; i++) {
            drawEdge(vs[es[i].v1], vs[es[i].v2]);
          }
          ctx.stroke();
        }

        function drawVerticeLabels() {
          for (var i = 0; i < vertices.length; i++) {
            var v = vertices[i];
            if (v == null) continue;
            var cv = mapVerticeToCanvas(v, canvas);
            drawLabel("V" + i, cv.x + 2, cv.y + 2);
          }
        }
        function drawEdgeLabels() {
          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];
            var v1 = vertices[edge.v1];
            var v2 = vertices[edge.v2];
            var midPointVertice = makeVertice(
              Math.min(v1.x, v2.x) +
                (Math.max(v1.x, v2.x) - Math.min(v1.x, v2.x)) * 0.5,
              Math.min(v1.y, v2.y) +
                (Math.max(v1.y, v2.y) - Math.min(v1.y, v2.y)) * 0.5
            );
            var cv = mapVerticeToCanvas(midPointVertice, canvas);
            drawLabel("E" + i, cv.x, cv.y);
          }
        }
        function drawVertice(v) {
          var cv = mapVerticeToCanvas(v, canvas);
          var x = cv.x,
            y = cv.y;
          // TODO - handle type?
          ctx.rect(x - 3, y - 3, 3, 3);
        }

        function drawEdge(v1, v2, pct) {
          var cv1 = mapVerticeToCanvas(v1, canvas);
          var cv2 = mapVerticeToCanvas(v2, canvas);
          if (pct !== undefined) {
            cv2.x = cv1.x + (cv2.x - cv1.x) * pct;
            cv2.y = cv1.y + (cv2.y - cv1.y) * pct;
          }
          ctx.moveTo(cv1.x, cv1.y);
          ctx.lineTo(cv2.x, cv2.y);
        }

        function draw() {
          update();
          ctx.beginPath();
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;

          if (options.drawBackground) ctx.drawImage(backgroundImage, 0, 0);
          if (options.drawVertices) drawVertices(vertices);
          if (options.drawEdges) drawEdges(edges, vertices);

          if (options.drawVerticeLabels) drawVerticeLabels();
          if (options.drawEdgeLabels) drawEdgeLabels();

          if (selectedVertices.length > 0) {
            ctx.beginPath();
            ctx.strokeStyle = "red";
            ctx.lineWidth = 4;

            drawVertices(selectedVertices.map(vidx => vertices[vidx]));
          }
        }

        function drawLabel(text, x, y) {
          ctx.font = "monospace";
          ctx.fillStyle = "black";
          ctx.fillText(text, x, y);
        }

        function canvasEventHandler(event) {
          let minDist = 1000000;
          var closestVerticeIdx = null;
          if (event.type == "click") {
            if (event.altKey) {
              console.log(event);
              var cx = mapInputEventToCanvas(event, canvas);
              var newVertice = makeVertice(
                cx.x / canvas.width,
                cx.y / canvas.height
              );
              vertices.push(newVertice);
              selectedVertices = [];
              selectedEdges = [];
            } else {
              for (var i = 0; i < vertices.length; i++) {
                var v = vertices[i];
                if (v == null) continue;
                var cv = mapVerticeToCanvas(v, canvas);
                var xd = Math.abs(cv.x - event.x);
                var yd = Math.abs(cv.y - event.y);
                var d = Math.sqrt(Math.pow(xd, 2) + Math.pow(yd, 2));
                if (d < minDist) {
                  minDist = d;
                  closestVerticeIdx = i;
                }
              }
              if (minDist < 20 && closestVerticeIdx !== null) {
                if (event.shiftKey) {
                  selectedVertices.push(closestVerticeIdx);
                } else {
                  selectedVertices = [closestVerticeIdx];
                }
              }
            }
          } else if (event.type == "keyup") {
            if (event.key == "f") {
              // create new edge between two selected vertices
              // TODO create multiple edges spanning multple (>2)
              //      selected vertices
              if (selectedVertices.length == 2) {
                // direction does not matter
                var edge = makeEdge(selectedVertices[0], selectedVertices[1]);
                edges.push(edge);
              }
            } else if (event.key == "w") {
              // split edge, creating a new vertice at the
              // middle point of the edge, creating a new edge
              //     v1       e1         v2
              //      x-------------------x
              //   split edge ->
              //     v1  e1   v3   e2    v2
              //      x--------x----------x
              if (selectedVertices.length == 2) {
                var v1idx = selectedVertices[0];
                var v2idx = selectedVertices[1];
                var i;
                console.log("finding edge between vertices ");
                var foundEdgeIdx = -1;
                for (i = 0; i < edges.length; i++) {
                  var edge = edges[i];
                  if (
                    (edge.v1 == v1idx && edge.v2 == v2idx) ||
                    (edge.v1 == v2idx && edge.v2 == v1idx)
                  ) {
                    console.log("edge found ", edge);
                    if (foundEdgeIdx != -1)
                      console.warn(
                        "duplicate edge found, previous is ",
                        edges[foundEdgeIdx]
                      );
                    foundEdgeIdx = i;
                  }
                }
                if (foundEdgeIdx != -1) {
                  var edge = edges[foundEdgeIdx];
                  console.log("splitting edge ", edge);
                  var v1 = vertices[v1idx];
                  var v2 = vertices[v2idx];
                  var newVertice = makeVertice(
                    Math.min(v1.x, v2.x) +
                      (Math.max(v1.x, v2.x) - Math.min(v1.x, v2.x)) * 0.5,
                    Math.min(v1.y, v2.y) +
                      (Math.max(v1.y, v2.y) - Math.min(v1.y, v2.y)) * 0.5
                  );
                  var newVerticeIdx = vertices.length;
                  vertices.push(newVertice);

                  if (edge.v1 == v1idx) {
                    edge.v2 = newVerticeIdx;
                    var newEdge = makeEdge(newVerticeIdx, v2idx);
                  } else if (edge.v1 == v2idx) {
                    edge.v1 = newVerticeIdx;
                    var newEdge = makeEdge(newVerticeIdx, v2idx);
                  } else {
                    throw new Exception("runtime error, weird edge");
                  }

                  edges.push(newEdge);
                  console.log("creadted vertice ", newVertice);
                  console.log("created edge ", newEdge);
                }
              }
            } else if (event.key == "x") {
              if (selectedVertices.length == 1) {
                var v = selectedVertices[0];
                console.log(
                  "finding and deleting edges connected to vertice ",
                  selectedVertices[0]
                );
                var numEdgesPreDeletion = edges.length;
                edges = edges.filter(edge => edge.v1 != v && edge.v2 != v);
                console.log(
                  "deleted ",
                  numEdgesPreDeletion - edges.length,
                  " edges"
                );
                vertices[v] = null;
              }
            }
          }
          // TODO - determine if redraw is needed?
          draw();
        }
        // load vertice & edge data from remote url
        function loadData(url) {
          const xhr = new XMLHttpRequest();
          xhr.open("get", url, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4 && xhr.status == 200) {
              let data = JSON.parse(xhr.responseText);
              console.log("loaded data!");
              vertices = data.vertices;
              edges = data.edges;
              draw();
            }
          };
          xhr.send();
        }
        // utility function for drawing a mark (an X) on the canvas
        // mostly for debugging purposes
        function cross(x, y, size, strokeStyle) {
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.strokeStyle = strokeStyle || "#00ff00";
          ctx.moveTo(x - size, y - size);
          ctx.lineTo(x + size, y + size);
          ctx.moveTo(x - size, y + size);
          ctx.lineTo(x + size, y - size);
          ctx.stroke();
          ctx.beginPath();
        }
        backgroundImage.src = "background.png";
        backgroundImage.addEventListener("load", e => {
          console.log("image loaded, initing");
          canvas.width = backgroundImage.width;
          canvas.height = backgroundImage.height;

          init();
          loadData("vertices.json");
        });
        function _defragmentVerticesAndEdges(vertices, edges) {
          var newVertices = [];
          var newEdges = [];
          var m = {};
          var i, j, m, n;
          var vertice, edge, v1, v2;
          j = 0;
          for (i = 0; i < vertices.length; i++) {
            vertice = vertices[i];
            if (vertice == null) continue;
            newVertices.push(vertice);
            m[i] = j;
            j += 1;
          }
          for (i = 0; i < edges.length; i++) {
            edge = edges[i];
            v1 = edge.v1;
            v2 = edge.v2;
            newEdges.push(makeEdge(m[v1], m[v2]));
          }

          return [newVertices, newEdges];
        }
        // utility function from removing "holes" in the vertice
        // list. holes (=nulls) are created when removing vertices
        function defragmentVerticesAndEdges(vs, es) {
          let o = _defragmentVerticesAndEdges(vs, es);
          vertices = o[0];
          edges = o[1];
          console.log(
            "defragmented, old v count:",
            vs.length,
            " new v count:",
            vertices.length
          );
        }
        //drawTasks.push(yyy([ 53, 46, 0, 1, 2, 4, 5, 6, 7 ])) ; processDrawTasks()
        //drawTasks.push(yyy([ 9,7,6,5,3,21,23,24,24,25,0,46,53,53,53,53,51,52 ])) ; processDrawTasks()
      })();
    </script>
  </body>
</html>
