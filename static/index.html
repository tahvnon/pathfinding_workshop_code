<html>
  <head>
    <title>node_editor</title>
    <meta charset="UTF-8" />
  </head>
  <body>
    <div>
      <canvas
        id="canvas1"
        style="border: 1px solid black;"
        width="800"
        height="600"
      ></canvas>
    </div>
    <div>
      <label for="cb_drawBackground">
        <input id="cb_drawBackground" type="checkbox" checked />Draw background
      </label>
      <label for="cb_drawVertices">
        <input id="cb_drawVertices" type="checkbox" checked />Draw vertices
      </label>
      <label for="cb_drawEdges">
        <input id="cb_drawEdges" type="checkbox" checked />Draw edges
      </label>
      <label for="cb_drawVerticeLabels">
        <input id="cb_drawVerticeLabels" type="checkbox" checked />Draw vertice
        labels
      </label>
      <label for="cb_drawEdgeLabels">
        <input id="cb_drawEdgeLabels" type="checkbox" checked />Draw edge labels
      </label>
    </div>
    <div>
      <span
        >enter vertice numbers separated by spaces. click 'draw path' to
        specified path.</span
      ><br />
      <input type="button" id="btn_drawPath" value="draw path" /><br />
      <textarea id="txt_path_input" rows="5" cols="80"></textarea><br />
      <span id="txt_path_input_error" style="color: red;display:none"> </span>
    </div>
    <div>
      <textarea id="txt_output1" rows="5" cols="80"></textarea>
      <input type="button" id="btn_updateOutput" value="Update" /><br />
    </div>
    <div>
      <input type="button" id="btn_bfs" value="bfs" />
      <input type="button" id="btn_bellmanFord" value="Bellman-Ford" />
    </div>
    <script src="app.js"></script>
    <script src="graphM.js"></script>
    <script>
      let app = new NodeEditorApp("/vertices.json", "/background.png");

      // this function takes vertices and edges in the node editor format and creates a GraphM graph from them
      function createGraphM_from_node_editor_vertices_and_edges(
        vertices,
        edges
      ) {
        let g = new GraphM();
        const pick_the_one_that_is_not_x = (a, b, x) => {
          return a == x ? b : a;
        };
        const convertedEdges = (res = vertices.map((_, vertex) => {
          return edges
            .filter(edge => {
              return edge.v1 === vertex || edge.v2 === vertex;
            })
            .map(edge => {
              return {
                name: pick_the_one_that_is_not_x(
                  edge.v1,
                  edge.v2,
                  vertex
                ).toString(),
                weight: app.calcDistance(vertices[edge.v1], vertices[edge.v2])
              };
            });
        }));
        window.D = [convertedEdges];
        convertedEdges.forEach((edges, i) => {
          g.addVertex(i.toString(), edges);
        });
        return g;
      }

      document.getElementById("btn_bfs").addEventListener("click", function() {
        console.log("do bfs");
        doit("bfs");
      });
      document
        .getElementById("btn_bellmanFord")
        .addEventListener("click", function() {
          console.log("do bfs");
          doit("bellmanFord");
        });

      function doit(algorithm) {
        let selectedVertices = app.getSelectedVertices();
        if (selectedVertices.length !== 2) {
          alert("select two vertices");
          return;
        }
        let g = createGraphM_from_node_editor_vertices_and_edges(
          app.getVertices(),
          app.getEdges()
        );
        let paths;
        if (algorithm === "bfs") {
          paths = g.bfs(selectedVertices[0].toString());
        } else if (algorithm === "bellmanFord") {
          paths = g.bellmanFord(selectedVertices[0].toString());
        }
        app.drawPath(
          paths.allPaths.get(selectedVertices[1].toString()).map(i => {
            return parseInt(i);
          })
        );
      }
    </script>
  </body>
</html>
